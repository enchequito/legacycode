{"ts":1356019772076,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// lib/handlebars/base.js\nvar Handlebars = {};\n\nHandlebars.VERSION = \"1.0.beta.6\";\n\nHandlebars.helpers  = {};\nHandlebars.partials = {};\n\nHandlebars.registerHelper = function(name, fn, inverse) {\n  if(inverse) { fn.not = inverse; }\n  this.helpers[name] = fn;\n};\n\nHandlebars.registerPartial = function(name, str) {\n  this.partials[name] = str;\n};\n\nHandlebars.registerHelper('helperMissing', function(arg) {\n  if(arguments.length === 2) {\n    return undefined;\n  } else {\n    throw new Error(\"Could not find property '\" + arg + \"'\");\n  }\n});\n\nvar toString = Object.prototype.toString, functionType = \"[object Function]\";\n\nHandlebars.registerHelper('blockHelperMissing', function(context, options) {\n  var inverse = options.inverse || function() {}, fn = options.fn;\n\n\n  var ret = \"\";\n  var type = toString.call(context);\n\n  if(type === functionType) { context = context.call(this); }\n\n  if(context === true) {\n    return fn(this);\n  } else if(context === false || context == null) {\n    return inverse(this);\n  } else if(type === \"[object Array]\") {\n    if(context.length > 0) {\n      for(var i=0, j=context.length; i<j; i++) {\n        ret = ret + fn(context[i]);\n      }\n    } else {\n      ret = inverse(this);\n    }\n    return ret;\n  } else {\n    return fn(context);\n  }\n});\n\nHandlebars.registerHelper('each', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  var ret = \"\";\n\n  if(context && context.length > 0) {\n    for(var i=0, j=context.length; i<j; i++) {\n      ret = ret + fn(context[i]);\n    }\n  } else {\n    ret = inverse(this);\n  }\n  return ret;\n});\n\nHandlebars.registerHelper('if', function(context, options) {\n  var type = toString.call(context);\n  if(type === functionType) { context = context.call(this); }\n\n  if(!context || Handlebars.Utils.isEmpty(context)) {\n    return options.inverse(this);\n  } else {\n    return options.fn(this);\n  }\n});\n\nHandlebars.registerHelper('unless', function(context, options) {\n  var fn = options.fn, inverse = options.inverse;\n  options.fn = inverse;\n  options.inverse = fn;\n\n  return Handlebars.helpers['if'].call(this, context, options);\n});\n\nHandlebars.registerHelper('with', function(context, options) {\n  return options.fn(context);\n});\n\nHandlebars.registerHelper('log', function(context) {\n  Handlebars.log(context);\n});\n;\n// lib/handlebars/compiler/parser.js\n/* Jison generated parser */\nvar handlebars = (function(){\n\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"program\":4,\"EOF\":5,\"statements\":6,\"simpleInverse\":7,\"statement\":8,\"openInverse\":9,\"closeBlock\":10,\"openBlock\":11,\"mustache\":12,\"partial\":13,\"CONTENT\":14,\"COMMENT\":15,\"OPEN_BLOCK\":16,\"inMustache\":17,\"CLOSE\":18,\"OPEN_INVERSE\":19,\"OPEN_ENDBLOCK\":20,\"path\":21,\"OPEN\":22,\"OPEN_UNESCAPED\":23,\"OPEN_PARTIAL\":24,\"params\":25,\"hash\":26,\"param\":27,\"STRING\":28,\"INTEGER\":29,\"BOOLEAN\":30,\"hashSegments\":31,\"hashSegment\":32,\"ID\":33,\"EQUALS\":34,\"pathSegments\":35,\"SEP\":36,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",14:\"CONTENT\",15:\"COMMENT\",16:\"OPEN_BLOCK\",18:\"CLOSE\",19:\"OPEN_INVERSE\",20:\"OPEN_ENDBLOCK\",22:\"OPEN\",23:\"OPEN_UNESCAPED\",24:\"OPEN_PARTIAL\",28:\"STRING\",29:\"INTEGER\",30:\"BOOLEAN\",33:\"ID\",34:\"EQUALS\",36:\"SEP\"},\nproductions_: [0,[3,2],[4,3],[4,1],[4,0],[6,1],[6,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,3],[13,4],[7,2],[17,3],[17,2],[17,2],[17,1],[25,2],[25,1],[27,1],[27,1],[27,1],[27,1],[26,1],[31,2],[31,1],[32,3],[32,3],[32,3],[32,3],[21,1],[35,3],[35,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return $$[$0-1] \nbreak;\ncase 2: this.$ = new yy.ProgramNode($$[$0-2], $$[$0]) \nbreak;\ncase 3: this.$ = new yy.ProgramNode($$[$0]) \nbreak;\ncase 4: this.$ = new yy.ProgramNode([]) \nbreak;\ncase 5: this.$ = [$$[$0]] \nbreak;\ncase 6: $$[$0-1].push($$[$0]); this.$ = $$[$0-1] \nbreak;\ncase 7: this.$ = new yy.InverseNode($$[$0-2], $$[$0-1], $$[$0]) \nbreak;\ncase 8: this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0]) \nbreak;\ncase 9: this.$ = $$[$0] \nbreak;\ncase 10: this.$ = $$[$0] \nbreak;\ncase 11: this.$ = new yy.ContentNode($$[$0]) \nbreak;\ncase 12: this.$ = new yy.CommentNode($$[$0]) \nbreak;\ncase 13: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]) \nbreak;\ncase 14: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]) \nbreak;\ncase 15: this.$ = $$[$0-1] \nbreak;\ncase 16: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1]) \nbreak;\ncase 17: this.$ = new yy.MustacheNode($$[$0-1][0], $$[$0-1][1], true) \nbreak;\ncase 18: this.$ = new yy.PartialNode($$[$0-1]) \nbreak;\ncase 19: this.$ = new yy.PartialNode($$[$0-2], $$[$0-1]) \nbreak;\ncase 20: \nbreak;\ncase 21: this.$ = [[$$[$0-2]].concat($$[$0-1]), $$[$0]] \nbreak;\ncase 22: this.$ = [[$$[$0-1]].concat($$[$0]), null] \nbreak;\ncase 23: this.$ = [[$$[$0-1]], $$[$0]] \nbreak;\ncase 24: this.$ = [[$$[$0]], null] \nbreak;\ncase 25: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; \nbreak;\ncase 26: this.$ = [$$[$0]] \nbreak;\ncase 27: this.$ = $$[$0] \nbreak;\ncase 28: this.$ = new yy.StringNode($$[$0]) \nbreak;\ncase 29: this.$ = new yy.IntegerNode($$[$0]) \nbreak;\ncase 30: this.$ = new yy.BooleanNode($$[$0]) \nbreak;\ncase 31: this.$ = new yy.HashNode($$[$0]) \nbreak;\ncase 32: $$[$0-1].push($$[$0]); this.$ = $$[$0-1] \nbreak;\ncase 33: this.$ = [$$[$0]] \nbreak;\ncase 34: this.$ = [$$[$0-2], $$[$0]] \nbreak;\ncase 35: this.$ = [$$[$0-2], new yy.StringNode($$[$0])] \nbreak;\ncase 36: this.$ = [$$[$0-2], new yy.IntegerNode($$[$0])] \nbreak;\ncase 37: this.$ = [$$[$0-2], new yy.BooleanNode($$[$0])] \nbreak;\ncase 38: this.$ = new yy.IdNode($$[$0]) \nbreak;\ncase 39: $$[$0-2].push($$[$0]); this.$ = $$[$0-2]; \nbreak;\ncase 40: this.$ = [$$[$0]] \nbreak;\n}\n},\ntable: [{3:1,4:2,5:[2,4],6:3,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],24:[1,15]},{1:[3]},{5:[1,16]},{5:[2,3],7:17,8:18,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,19],20:[2,3],22:[1,13],23:[1,14],24:[1,15]},{5:[2,5],14:[2,5],15:[2,5],16:[2,5],19:[2,5],20:[2,5],22:[2,5],23:[2,5],24:[2,5]},{4:20,6:3,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,4],22:[1,13],23:[1,14],24:[1,15]},{4:21,6:3,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,4],22:[1,13],23:[1,14],24:[1,15]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],24:[2,9]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],24:[2,10]},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],24:[2,11]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],24:[2,12]},{17:22,21:23,33:[1,25],35:24},{17:26,21:23,33:[1,25],35:24},{17:27,21:23,33:[1,25],35:24},{17:28,21:23,33:[1,25],35:24},{21:29,33:[1,25],35:24},{1:[2,1]},{6:30,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],24:[1,15]},{5:[2,6],14:[2,6],15:[2,6],16:[2,6],19:[2,6],20:[2,6],22:[2,6],23:[2,6],24:[2,6]},{17:22,18:[1,31],21:23,33:[1,25],35:24},{10:32,20:[1,33]},{10:34,20:[1,33]},{18:[1,35]},{18:[2,24],21:40,25:36,26:37,27:38,28:[1,41],29:[1,42],30:[1,43],31:39,32:44,33:[1,45],35:24},{18:[2,38],28:[2,38],29:[2,38],30:[2,38],33:[2,38],36:[1,46]},{18:[2,40],28:[2,40],29:[2,40],30:[2,40],33:[2,40],36:[2,40]},{18:[1,47]},{18:[1,48]},{18:[1,49]},{18:[1,50],21:51,33:[1,25],35:24},{5:[2,2],8:18,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,2],22:[1,13],23:[1,14],24:[1,15]},{14:[2,20],15:[2,20],16:[2,20],19:[2,20],22:[2,20],23:[2,20],24:[2,20]},{5:[2,7],14:[2,7],15:[2,7],16:[2,7],19:[2,7],20:[2,7],22:[2,7],23:[2,7],24:[2,7]},{21:52,33:[1,25],35:24},{5:[2,8],14:[2,8],15:[2,8],16:[2,8],19:[2,8],20:[2,8],22:[2,8],23:[2,8],24:[2,8]},{14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],24:[2,14]},{18:[2,22],21:40,26:53,27:54,28:[1,41],29:[1,42],30:[1,43],31:39,32:44,33:[1,45],35:24},{18:[2,23]},{18:[2,26],28:[2,26],29:[2,26],30:[2,26],33:[2,26]},{18:[2,31],32:55,33:[1,56]},{18:[2,27],28:[2,27],29:[2,27],30:[2,27],33:[2,27]},{18:[2,28],28:[2,28],29:[2,28],30:[2,28],33:[2,28]},{18:[2,29],28:[2,29],29:[2,29],30:[2,29],33:[2,29]},{18:[2,30],28:[2,30],29:[2,30],30:[2,30],33:[2,30]},{18:[2,33],33:[2,33]},{18:[2,40],28:[2,40],29:[2,40],30:[2,40],33:[2,40],34:[1,57],36:[2,40]},{33:[1,58]},{14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],24:[2,13]},{5:[2,16],14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],24:[2,16]},{5:[2,17],14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],24:[2,17]},{5:[2,18],14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],24:[2,18]},{18:[1,59]},{18:[1,60]},{18:[2,21]},{18:[2,25],28:[2,25],29:[2,25],30:[2,25],33:[2,25]},{18:[2,32],33:[2,32]},{34:[1,57]},{21:61,28:[1,62],29:[1,63],30:[1,64],33:[1,25],35:24},{18:[2,39],28:[2,39],29:[2,39],30:[2,39],33:[2,39],36:[2,39]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],24:[2,19]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],24:[2,15]},{18:[2,34],33:[2,34]},{18:[2,35],33:[2,35]},{18:[2,36],33:[2,36]},{18:[2,37],33:[2,37]}],\ndefaultActions: {16:[2,1],37:[2,23],53:[2,21]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = \"\", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == \"undefined\")\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n    if (typeof this.yy.parseError === \"function\")\n        this.parseError = this.yy.parseError;\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1;\n        if (typeof token !== \"number\") {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol == null)\n                symbol = lex();\n            action = table[state] && table[state][symbol];\n        }\n        if (typeof action === \"undefined\" || !action.length || !action[0]) {\n            if (!recovering) {\n                expected = [];\n                for (p in table[state])\n                    if (this.terminals_[p] && p > 2) {\n                        expected.push(\"'\" + this.terminals_[p] + \"'\");\n                    }\n                var errStr = \"\";\n                if (this.lexer.showPosition) {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \":\\n\" + this.lexer.showPosition() + \"\\nExpecting \" + expected.join(\", \") + \", got '\" + this.terminals_[symbol] + \"'\";\n                } else {\n                    errStr = \"Parse error on line \" + (yylineno + 1) + \": Unexpected \" + (symbol == 1?\"end of input\":\"'\" + (this.terminals_[symbol] || symbol) + \"'\");\n                }\n                this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n        }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error(\"Parse Error: multiple actions possible at state: \" + state + \", token: \" + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(this.lexer.yytext);\n            lstack.push(this.lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                if (recovering > 0)\n                    recovering--;\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};\n            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n            if (typeof r !== \"undefined\") {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}\n};/* Jison generated lexer */\nvar lexer = (function(){\n\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            match = this._input.match(this.rules[rules[i]]);\n            if (match) {\n                lines = match[0].match(/\\n.*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = {first_line: this.yylloc.last_line,\n                               last_line: this.yylineno+1,\n                               first_column: this.yylloc.last_column,\n                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length}\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);\n                if (token) return token;\n                else return;\n            }\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(), \n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START\nswitch($avoiding_name_collisions) {\ncase 0:\n                                   if(yy_.yytext.slice(-1) !== \"\\\\\") this.begin(\"mu\");\n                                   if(yy_.yytext.slice(-1) === \"\\\\\") yy_.yytext = yy_.yytext.substr(0,yy_.yyleng-1), this.begin(\"emu\");\n                                   if(yy_.yytext) return 14;\n                                 \nbreak;\ncase 1: return 14; \nbreak;\ncase 2: this.popState(); return 14; \nbreak;\ncase 3: return 24; \nbreak;\ncase 4: return 16; \nbreak;\ncase 5: return 20; \nbreak;\ncase 6: return 19; \nbreak;\ncase 7: return 19; \nbreak;\ncase 8: return 23; \nbreak;\ncase 9: return 23; \nbreak;\ncase 10: yy_.yytext = yy_.yytext.substr(3,yy_.yyleng-5); this.popState(); return 15; \nbreak;\ncase 11: return 22; \nbreak;\ncase 12: return 34; \nbreak;\ncase 13: return 33; \nbreak;\ncase 14: return 33; \nbreak;\ncase 15: return 36; \nbreak;\ncase 16: /*ignore whitespace*/ \nbreak;\ncase 17: this.popState(); return 18; \nbreak;\ncase 18: this.popState(); return 18; \nbreak;\ncase 19: yy_.yytext = yy_.yytext.substr(1,yy_.yyleng-2).replace(/\\\\\"/g,'\"'); return 28; \nbreak;\ncase 20: return 30; \nbreak;\ncase 21: return 30; \nbreak;\ncase 22: return 29; \nbreak;\ncase 23: return 33; \nbreak;\ncase 24: yy_.yytext = yy_.yytext.substr(1, yy_.yyleng-2); return 33; \nbreak;\ncase 25: return 'INVALID'; \nbreak;\ncase 26: return 5; \nbreak;\n}\n};\nlexer.rules = [/^[^\\x00]*?(?=(\\{\\{))/,/^[^\\x00]+/,/^[^\\x00]{2,}?(?=(\\{\\{))/,/^\\{\\{>/,/^\\{\\{#/,/^\\{\\{\\//,/^\\{\\{\\^/,/^\\{\\{\\s*else\\b/,/^\\{\\{\\{/,/^\\{\\{&/,/^\\{\\{![\\s\\S]*?\\}\\}/,/^\\{\\{/,/^=/,/^\\.(?=[} ])/,/^\\.\\./,/^[\\/.]/,/^\\s+/,/^\\}\\}\\}/,/^\\}\\}/,/^\"(\\\\[\"]|[^\"])*\"/,/^true(?=[}\\s])/,/^false(?=[}\\s])/,/^[0-9]+(?=[}\\s])/,/^[a-zA-Z0-9_$-]+(?=[=}\\s\\/.])/,/^\\[[^\\]]*\\]/,/^./,/^$/];\nlexer.conditions = {\"mu\":{\"rules\":[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26],\"inclusive\":false},\"emu\":{\"rules\":[2],\"inclusive\":false},\"INITIAL\":{\"rules\":[0,1,26],\"inclusive\":true}};return lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = handlebars;\nexports.parse = function () { return handlebars.parse.apply(handlebars, arguments); }\nexports.main = function commonjsMain(args) {\n    if (!args[1])\n        throw new Error('Usage: '+args[0]+' FILE');\n    if (typeof process !== 'undefined') {\n        var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\");\n    } else {\n        var cwd = require(\"file\").path(require(\"file\").cwd());\n        var source = cwd.join(args[1]).read({charset: \"utf-8\"});\n    }\n    return exports.parser.parse(source);\n}\nif (typeof module !== 'undefined' && require.main === module) {\n  exports.main(typeof process !== 'undefined' ? process.argv.slice(1) : require(\"system\").args);\n}\n};\n;\n// lib/handlebars/compiler/base.js\nHandlebars.Parser = handlebars;\n\nHandlebars.parse = function(string) {\n  Handlebars.Parser.yy = Handlebars.AST;\n  return Handlebars.Parser.parse(string);\n};\n\nHandlebars.print = function(ast) {\n  return new Handlebars.PrintVisitor().accept(ast);\n};\n\nHandlebars.logger = {\n  DEBUG: 0, INFO: 1, WARN: 2, ERROR: 3, level: 3,\n\n  // override in the host environment\n  log: function(level, str) {}\n};\n\nHandlebars.log = function(level, str) { Handlebars.logger.log(level, str); };\n;\n// lib/handlebars/compiler/ast.js\n(function() {\n\n  Handlebars.AST = {};\n\n  Handlebars.AST.ProgramNode = function(statements, inverse) {\n    this.type = \"program\";\n    this.statements = statements;\n    if(inverse) { this.inverse = new Handlebars.AST.ProgramNode(inverse); }\n  };\n\n  Handlebars.AST.MustacheNode = function(params, hash, unescaped) {\n    this.type = \"mustache\";\n    this.id = params[0];\n    this.params = params.slice(1);\n    this.hash = hash;\n    this.escaped = !unescaped;\n  };\n\n  Handlebars.AST.PartialNode = function(id, context) {\n    this.type    = \"partial\";\n\n    // TODO: disallow complex IDs\n\n    this.id      = id;\n    this.context = context;\n  };\n\n  var verifyMatch = function(open, close) {\n    if(open.original !== close.original) {\n      throw new Handlebars.Exception(open.original + \" doesn't match \" + close.original);\n    }\n  };\n\n  Handlebars.AST.BlockNode = function(mustache, program, close) {\n    verifyMatch(mustache.id, close);\n    this.type = \"block\";\n    this.mustache = mustache;\n    this.program  = program;\n  };\n\n  Handlebars.AST.InverseNode = function(mustache, program, close) {\n    verifyMatch(mustache.id, close);\n    this.type = \"inverse\";\n    this.mustache = mustache;\n    this.program  = program;\n  };\n\n  Handlebars.AST.ContentNode = function(string) {\n    this.type = \"content\";\n    this.string = string;\n  };\n\n  Handlebars.AST.HashNode = function(pairs) {\n    this.type = \"hash\";\n    this.pairs = pairs;\n  };\n\n  Handlebars.AST.IdNode = function(parts) {\n    this.type = \"ID\";\n    this.original = parts.join(\".\");\n\n    var dig = [], depth = 0;\n\n    for(var i=0,l=parts.length; i<l; i++) {\n      var part = parts[i];\n\n      if(part === \"..\") { depth++; }\n      else if(part === \".\" || part === \"this\") { this.isScoped = true; }\n      else { dig.push(part); }\n    }\n\n    this.parts    = dig;\n    this.string   = dig.join('.');\n    this.depth    = depth;\n    this.isSimple = (dig.length === 1) && (depth === 0);\n  };\n\n  Handlebars.AST.StringNode = function(string) {\n    this.type = \"STRING\";\n    this.string = string;\n  };\n\n  Handlebars.AST.IntegerNode = function(integer) {\n    this.type = \"INTEGER\";\n    this.integer = integer;\n  };\n\n  Handlebars.AST.BooleanNode = function(bool) {\n    this.type = \"BOOLEAN\";\n    this.bool = bool;\n  };\n\n  Handlebars.AST.CommentNode = function(comment) {\n    this.type = \"comment\";\n    this.comment = comment;\n  };\n\n})();;\n// lib/handlebars/utils.js\nHandlebars.Exception = function(message) {\n  var tmp = Error.prototype.constructor.apply(this, arguments);\n\n  for (var p in tmp) {\n    if (tmp.hasOwnProperty(p)) { this[p] = tmp[p]; }\n  }\n\n  this.message = tmp.message;\n};\nHandlebars.Exception.prototype = new Error;\n\n// Build out our basic SafeString type\nHandlebars.SafeString = function(string) {\n  this.string = string;\n};\nHandlebars.SafeString.prototype.toString = function() {\n  return this.string.toString();\n};\n\n(function() {\n  var escape = {\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#x27;\",\n    \"`\": \"&#x60;\"\n  };\n\n  var badChars = /&(?!\\w+;)|[<>\"'`]/g;\n  var possible = /[&<>\"'`]/;\n\n  var escapeChar = function(chr) {\n    return escape[chr] || \"&amp;\";\n  };\n\n  Handlebars.Utils = {\n    escapeExpression: function(string) {\n      // don't escape SafeStrings, since they're already safe\n      if (string instanceof Handlebars.SafeString) {\n        return string.toString();\n      } else if (string == null || string === false) {\n        return \"\";\n      }\n\n      if(!possible.test(string)) { return string; }\n      return string.replace(badChars, escapeChar);\n    },\n\n    isEmpty: function(value) {\n      if (typeof value === \"undefined\") {\n        return true;\n      } else if (value === null) {\n        return true;\n      } else if (value === false) {\n        return true;\n      } else if(Object.prototype.toString.call(value) === \"[object Array]\" && value.length === 0) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  };\n})();;\n// lib/handlebars/compiler/compiler.js\nHandlebars.Compiler = function() {};\nHandlebars.JavaScriptCompiler = function() {};\n\n(function(Compiler, JavaScriptCompiler) {\n  Compiler.OPCODE_MAP = {\n    appendContent: 1,\n    getContext: 2,\n    lookupWithHelpers: 3,\n    lookup: 4,\n    append: 5,\n    invokeMustache: 6,\n    appendEscaped: 7,\n    pushString: 8,\n    truthyOrFallback: 9,\n    functionOrFallback: 10,\n    invokeProgram: 11,\n    invokePartial: 12,\n    push: 13,\n    assignToHash: 15,\n    pushStringParam: 16\n  };\n\n  Compiler.MULTI_PARAM_OPCODES = {\n    appendContent: 1,\n    getContext: 1,\n    lookupWithHelpers: 2,\n    lookup: 1,\n    invokeMustache: 3,\n    pushString: 1,\n    truthyOrFallback: 1,\n    functionOrFallback: 1,\n    invokeProgram: 3,\n    invokePartial: 1,\n    push: 1,\n    assignToHash: 1,\n    pushStringParam: 1\n  };\n\n  Compiler.DISASSEMBLE_MAP = {};\n\n  for(var prop in Compiler.OPCODE_MAP) {\n    var value = Compiler.OPCODE_MAP[prop];\n    Compiler.DISASSEMBLE_MAP[value] = prop;\n  }\n\n  Compiler.multiParamSize = function(code) {\n    return Compiler.MULTI_PARAM_OPCODES[Compiler.DISASSEMBLE_MAP[code]];\n  };\n\n  Compiler.prototype = {\n    compiler: Compiler,\n\n    disassemble: function() {\n      var opcodes = this.opcodes, opcode, nextCode;\n      var out = [], str, name, value;\n\n      for(var i=0, l=opcodes.length; i<l; i++) {\n        opcode = opcodes[i];\n\n        if(opcode === 'DECLARE') {\n          name = opcodes[++i];\n          value = opcodes[++i];\n          out.push(\"DECLARE \" + name + \" = \" + value);\n        } else {\n          str = Compiler.DISASSEMBLE_MAP[opcode];\n\n          var extraParams = Compiler.multiParamSize(opcode);\n          var codes = [];\n\n          for(var j=0; j<extraParams; j++) {\n            nextCode = opcodes[++i];\n\n            if(typeof nextCode === \"string\") {\n              nextCode = \"\\\"\" + nextCode.replace(\"\\n\", \"\\\\n\") + \"\\\"\";\n            }\n\n            codes.push(nextCode);\n          }\n\n          str = str + \" \" + codes.join(\" \");\n\n          out.push(str);\n        }\n      }\n\n      return out.join(\"\\n\");\n    },\n\n    guid: 0,\n\n    compile: function(program, options) {\n      this.children = [];\n      this.depths = {list: []};\n      this.options = options;\n\n      // These changes will propagate to the other compiler components\n      var knownHelpers = this.options.knownHelpers;\n      this.options.knownHelpers = {\n        'helperMissing': true,\n        'blockHelperMissing': true,\n        'each': true,\n        'if': true,\n        'unless': true,\n        'with': true,\n        'log': true\n      };\n      if (knownHelpers) {\n        for (var name in knownHelpers) {\n          this.options.knownHelpers[name] = knownHelpers[name];\n        }\n      }\n\n      return this.program(program);\n    },\n\n    accept: function(node) {\n      return this[node.type](node);\n    },\n\n    program: function(program) {\n      var statements = program.statements, statement;\n      this.opcodes = [];\n\n      for(var i=0, l=statements.length; i<l; i++) {\n        statement = statements[i];\n        this[statement.type](statement);\n      }\n      this.isSimple = l === 1;\n\n      this.depths.list = this.depths.list.sort(function(a, b) {\n        return a - b;\n      });\n\n      return this;\n    },\n\n    compileProgram: function(program) {\n      var result = new this.compiler().compile(program, this.options);\n      var guid = this.guid++;\n\n      this.usePartial = this.usePartial || result.usePartial;\n\n      this.children[guid] = result;\n\n      for(var i=0, l=result.depths.list.length; i<l; i++) {\n        depth = result.depths.list[i];\n\n        if(depth < 2) { continue; }\n        else { this.addDepth(depth - 1); }\n      }\n\n      return guid;\n    },\n\n    block: function(block) {\n      var mustache = block.mustache;\n      var depth, child, inverse, inverseGuid;\n\n      var params = this.setupStackForMustache(mustache);\n\n      var programGuid = this.compileProgram(block.program);\n\n      if(block.program.inverse) {\n        inverseGuid = this.compileProgram(block.program.inverse);\n        this.declare('inverse', inverseGuid);\n      }\n\n      this.opcode('invokeProgram', programGuid, params.length, !!mustache.hash);\n      this.declare('inverse', null);\n      this.opcode('append');\n    },\n\n    inverse: function(block) {\n      var params = this.setupStackForMustache(block.mustache);\n\n      var programGuid = this.compileProgram(block.program);\n\n      this.declare('inverse', programGuid);\n\n      this.opcode('invokeProgram', null, params.length, !!block.mustache.hash);\n      this.declare('inverse', null);\n      this.opcode('append');\n    },\n\n    hash: function(hash) {\n      var pairs = hash.pairs, pair, val;\n\n      this.opcode('push', '{}');\n\n      for(var i=0, l=pairs.length; i<l; i++) {\n        pair = pairs[i];\n        val  = pair[1];\n\n        this.accept(val);\n        this.opcode('assignToHash', pair[0]);\n      }\n    },\n\n    partial: function(partial) {\n      var id = partial.id;\n      this.usePartial = true;\n\n      if(partial.context) {\n        this.ID(partial.context);\n      } else {\n        this.opcode('push', 'depth0');\n      }\n\n      this.opcode('invokePartial', id.original);\n      this.opcode('append');\n    },\n\n    content: function(content) {\n      this.opcode('appendContent', content.string);\n    },\n\n    mustache: function(mustache) {\n      var params = this.setupStackForMustache(mustache);\n\n      this.opcode('invokeMustache', params.length, mustache.id.original, !!mustache.hash);\n\n      if(mustache.escaped && !this.options.noEscape) {\n        this.opcode('appendEscaped');\n      } else {\n        this.opcode('append');\n      }\n    },\n\n    ID: function(id) {\n      this.addDepth(id.depth);\n\n      this.opcode('getContext', id.depth);\n\n      this.opcode('lookupWithHelpers', id.parts[0] || null, id.isScoped || false);\n\n      for(var i=1, l=id.parts.length; i<l; i++) {\n        this.opcode('lookup', id.parts[i]);\n      }\n    },\n\n    STRING: function(string) {\n      this.opcode('pushString', string.string);\n    },\n\n    INTEGER: function(integer) {\n      this.opcode('push', integer.integer);\n    },\n\n    BOOLEAN: function(bool) {\n      this.opcode('push', bool.bool);\n    },\n\n    comment: function() {},\n\n    // HELPERS\n    pushParams: function(params) {\n      var i = params.length, param;\n\n      while(i--) {\n        param = params[i];\n\n        if(this.options.stringParams) {\n          if(param.depth) {\n            this.addDepth(param.depth);\n          }\n\n          this.opcode('getContext', param.depth || 0);\n          this.opcode('pushStringParam', param.string);\n        } else {\n          this[param.type](param);\n        }\n      }\n    },\n\n    opcode: function(name, val1, val2, val3) {\n      this.opcodes.push(Compiler.OPCODE_MAP[name]);\n      if(val1 !== undefined) { this.opcodes.push(val1); }\n      if(val2 !== undefined) { this.opcodes.push(val2); }\n      if(val3 !== undefined) { this.opcodes.push(val3); }\n    },\n\n    declare: function(name, value) {\n      this.opcodes.push('DECLARE');\n      this.opcodes.push(name);\n      this.opcodes.push(value);\n    },\n\n    addDepth: function(depth) {\n      if(depth === 0) { return; }\n\n      if(!this.depths[depth]) {\n        this.depths[depth] = true;\n        this.depths.list.push(depth);\n      }\n    },\n\n    setupStackForMustache: function(mustache) {\n      var params = mustache.params;\n\n      this.pushParams(params);\n\n      if(mustache.hash) {\n        this.hash(mustache.hash);\n      }\n\n      this.ID(mustache.id);\n\n      return params;\n    }\n  };\n\n  JavaScriptCompiler.prototype = {\n    // PUBLIC API: You can override these methods in a subclass to provide\n    // alternative compiled forms for name lookup and buffering semantics\n    nameLookup: function(parent, name, type) {\n\t\t\tif (/^[0-9]+$/.test(name)) {\n        return parent + \"[\" + name + \"]\";\n      } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {\n\t    \treturn parent + \".\" + name;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn parent + \"['\" + name + \"']\";\n      }\n    },\n\n    appendToBuffer: function(string) {\n      if (this.environment.isSimple) {\n        return \"return \" + string + \";\";\n      } else {\n        return \"buffer += \" + string + \";\";\n      }\n    },\n\n    initializeBuffer: function() {\n      return this.quotedString(\"\");\n    },\n\n    namespace: \"Handlebars\",\n    // END PUBLIC API\n\n    compile: function(environment, options, context, asObject) {\n      this.environment = environment;\n      this.options = options || {};\n\n      this.name = this.environment.name;\n      this.isChild = !!context;\n      this.context = context || {\n        programs: [],\n        aliases: { self: 'this' },\n        registers: {list: []}\n      };\n\n      this.preamble();\n\n      this.stackSlot = 0;\n      this.stackVars = [];\n\n      this.compileChildren(environment, options);\n\n      var opcodes = environment.opcodes, opcode;\n\n      this.i = 0;\n\n      for(l=opcodes.length; this.i<l; this.i++) {\n        opcode = this.nextOpcode(0);\n\n        if(opcode[0] === 'DECLARE') {\n          this.i = this.i + 2;\n          this[opcode[1]] = opcode[2];\n        } else {\n          this.i = this.i + opcode[1].length;\n          this[opcode[0]].apply(this, opcode[1]);\n        }\n      }\n\n      return this.createFunctionContext(asObject);\n    },\n\n    nextOpcode: function(n) {\n      var opcodes = this.environment.opcodes, opcode = opcodes[this.i + n], name, val;\n      var extraParams, codes;\n\n      if(opcode === 'DECLARE') {\n        name = opcodes[this.i + 1];\n        val  = opcodes[this.i + 2];\n        return ['DECLARE', name, val];\n      } else {\n        name = Compiler.DISASSEMBLE_MAP[opcode];\n\n        extraParams = Compiler.multiParamSize(opcode);\n        codes = [];\n\n        for(var j=0; j<extraParams; j++) {\n          codes.push(opcodes[this.i + j + 1 + n]);\n        }\n\n        return [name, codes];\n      }\n    },\n\n    eat: function(opcode) {\n      this.i = this.i + opcode.length;\n    },\n\n    preamble: function() {\n      var out = [];\n\n      // this register will disambiguate helper lookup from finding a function in\n      // a context. This is necessary for mustache compatibility, which requires\n      // that context functions in blocks are evaluated by blockHelperMissing, and\n      // then proceed as if the resulting value was provided to blockHelperMissing.\n      this.useRegister('foundHelper');\n\n      if (!this.isChild) {\n        var namespace = this.namespace;\n        var copies = \"helpers = helpers || \" + namespace + \".helpers;\";\n        if(this.environment.usePartial) { copies = copies + \" partials = partials || \" + namespace + \".partials;\"; }\n        out.push(copies);\n      } else {\n        out.push('');\n      }\n\n      if (!this.environment.isSimple) {\n        out.push(\", buffer = \" + this.initializeBuffer());\n      } else {\n        out.push(\"\");\n      }\n\n      // track the last context pushed into place to allow skipping the\n      // getContext opcode when it would be a noop\n      this.lastContext = 0;\n      this.source = out;\n    },\n\n    createFunctionContext: function(asObject) {\n      var locals = this.stackVars;\n      if (!this.isChild) {\n        locals = locals.concat(this.context.registers.list);\n      }\n\n      if(locals.length > 0) {\n        this.source[1] = this.source[1] + \", \" + locals.join(\", \");\n      }\n\n      // Generate minimizer alias mappings\n      if (!this.isChild) {\n        var aliases = []\n        for (var alias in this.context.aliases) {\n          this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];\n        }\n      }\n\n      if (this.source[1]) {\n        this.source[1] = \"var \" + this.source[1].substring(2) + \";\";\n      }\n\n      // Merge children\n      if (!this.isChild) {\n        this.source[1] += '\\n' + this.context.programs.join('\\n') + '\\n';\n      }\n\n      if (!this.environment.isSimple) {\n        this.source.push(\"return buffer;\");\n      }\n\n      var params = this.isChild ? [\"depth0\", \"data\"] : [\"Handlebars\", \"depth0\", \"helpers\", \"partials\", \"data\"];\n\n      for(var i=0, l=this.environment.depths.list.length; i<l; i++) {\n        params.push(\"depth\" + this.environment.depths.list[i]);\n      }\n\n      if (asObject) {\n        params.push(this.source.join(\"\\n  \"));\n\n        return Function.apply(this, params);\n      } else {\n        var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\\n  ' + this.source.join(\"\\n  \") + '}';\n        Handlebars.log(Handlebars.logger.DEBUG, functionSource + \"\\n\\n\");\n        return functionSource;\n      }\n    },\n\n    appendContent: function(content) {\n      this.source.push(this.appendToBuffer(this.quotedString(content)));\n    },\n\n    append: function() {\n      var local = this.popStack();\n      this.source.push(\"if(\" + local + \" || \" + local + \" === 0) { \" + this.appendToBuffer(local) + \" }\");\n      if (this.environment.isSimple) {\n        this.source.push(\"else { \" + this.appendToBuffer(\"''\") + \" }\");\n      }\n    },\n\n    appendEscaped: function() {\n      var opcode = this.nextOpcode(1), extra = \"\";\n      this.context.aliases.escapeExpression = 'this.escapeExpression';\n\n      if(opcode[0] === 'appendContent') {\n        extra = \" + \" + this.quotedString(opcode[1][0]);\n        this.eat(opcode);\n      }\n\n      this.source.push(this.appendToBuffer(\"escapeExpression(\" + this.popStack() + \")\" + extra));\n    },\n\n    getContext: function(depth) {\n      if(this.lastContext !== depth) {\n        this.lastContext = depth;\n      }\n    },\n\n    lookupWithHelpers: function(name, isScoped) {\n      if(name) {\n        var topStack = this.nextStack();\n\n        this.usingKnownHelper = false;\n\n        var toPush;\n        if (!isScoped && this.options.knownHelpers[name]) {\n          toPush = topStack + \" = \" + this.nameLookup('helpers', name, 'helper');\n          this.usingKnownHelper = true;\n        } else if (isScoped || this.options.knownHelpersOnly) {\n          toPush = topStack + \" = \" + this.nameLookup('depth' + this.lastContext, name, 'context');\n        } else {\n          this.register('foundHelper', this.nameLookup('helpers', name, 'helper'));\n          toPush = topStack + \" = foundHelper || \" + this.nameLookup('depth' + this.lastContext, name, 'context');\n        }\n\n        toPush += ';';\n        this.source.push(toPush);\n      } else {\n        this.pushStack('depth' + this.lastContext);\n      }\n    },\n\n    lookup: function(name) {\n      var topStack = this.topStack();\n      this.source.push(topStack + \" = (\" + topStack + \" === null || \" + topStack + \" === undefined || \" + topStack + \" === false ? \" +\n \t\t\t\ttopStack + \" : \" + this.nameLookup(topStack, name, 'context') + \");\");\n    },\n\n    pushStringParam: function(string) {\n      this.pushStack('depth' + this.lastContext);\n      this.pushString(string);\n    },\n\n    pushString: function(string) {\n      this.pushStack(this.quotedString(string));\n    },\n\n    push: function(name) {\n      this.pushStack(name);\n    },\n\n    invokeMustache: function(paramSize, original, hasHash) {\n      this.populateParams(paramSize, this.quotedString(original), \"{}\", null, hasHash, function(nextStack, helperMissingString, id) {\n        if (!this.usingKnownHelper) {\n          this.context.aliases.helperMissing = 'helpers.helperMissing';\n          this.context.aliases.undef = 'void 0';\n          this.source.push(\"else if(\" + id + \"=== undef) { \" + nextStack + \" = helperMissing.call(\" + helperMissingString + \"); }\");\n          if (nextStack !== id) {\n            this.source.push(\"else { \" + nextStack + \" = \" + id + \"; }\");\n          }\n        }\n      });\n    },\n\n    invokeProgram: function(guid, paramSize, hasHash) {\n      var inverse = this.programExpression(this.inverse);\n      var mainProgram = this.programExpression(guid);\n\n      this.populateParams(paramSize, null, mainProgram, inverse, hasHash, function(nextStack, helperMissingString, id) {\n        if (!this.usingKnownHelper) {\n          this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';\n          this.source.push(\"else { \" + nextStack + \" = blockHelperMissing.call(\" + helperMissingString + \"); }\");\n        }\n      });\n    },\n\n    populateParams: function(paramSize, helperId, program, inverse, hasHash, fn) {\n      var needsRegister = hasHash || this.options.stringParams || inverse || this.options.data;\n      var id = this.popStack(), nextStack;\n      var params = [], param, stringParam, stringOptions;\n\n      if (needsRegister) {\n        this.register('tmp1', program);\n        stringOptions = 'tmp1';\n      } else {\n        stringOptions = '{ hash: {} }';\n      }\n\n      if (needsRegister) {\n        var hash = (hasHash ? this.popStack() : '{}');\n        this.source.push('tmp1.hash = ' + hash + ';');\n      }\n\n      if(this.options.stringParams) {\n        this.source.push('tmp1.contexts = [];');\n      }\n\n      for(var i=0; i<paramSize; i++) {\n        param = this.popStack();\n        params.push(param);\n\n        if(this.options.stringParams) {\n          this.source.push('tmp1.contexts.push(' + this.popStack() + ');');\n        }\n      }\n\n      if(inverse) {\n        this.source.push('tmp1.fn = tmp1;');\n        this.source.push('tmp1.inverse = ' + inverse + ';');\n      }\n\n      if(this.options.data) {\n        this.source.push('tmp1.data = data;');\n      }\n\n      params.push(stringOptions);\n\n      this.populateCall(params, id, helperId || id, fn, program !== '{}');\n    },\n\n    populateCall: function(params, id, helperId, fn, program) {\n      var paramString = [\"depth0\"].concat(params).join(\", \");\n      var helperMissingString = [\"depth0\"].concat(helperId).concat(params).join(\", \");\n\n      var nextStack = this.nextStack();\n\n      if (this.usingKnownHelper) {\n        this.source.push(nextStack + \" = \" + id + \".call(\" + paramString + \");\");\n      } else {\n        this.context.aliases.functionType = '\"function\"';\n        var condition = program ? \"foundHelper && \" : \"\"\n        this.source.push(\"if(\" + condition + \"typeof \" + id + \" === functionType) { \" + nextStack + \" = \" + id + \".call(\" + paramString + \"); }\");\n      }\n      fn.call(this, nextStack, helperMissingString, id);\n      this.usingKnownHelper = false;\n    },\n\n    invokePartial: function(context) {\n      params = [this.nameLookup('partials', context, 'partial'), \"'\" + context + \"'\", this.popStack(), \"helpers\", \"partials\"];\n\n      if (this.options.data) {\n        params.push(\"data\");\n      }\n\n      this.pushStack(\"self.invokePartial(\" + params.join(\", \") + \");\");\n    },\n\n    assignToHash: function(key) {\n      var value = this.popStack();\n      var hash = this.topStack();\n\n      this.source.push(hash + \"['\" + key + \"'] = \" + value + \";\");\n    },\n\n    // HELPERS\n\n    compiler: JavaScriptCompiler,\n\n    compileChildren: function(environment, options) {\n      var children = environment.children, child, compiler;\n\n      for(var i=0, l=children.length; i<l; i++) {\n        child = children[i];\n        compiler = new this.compiler();\n\n        this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children\n        var index = this.context.programs.length;\n        child.index = index;\n        child.name = 'program' + index;\n        this.context.programs[index] = compiler.compile(child, options, this.context);\n      }\n    },\n\n    programExpression: function(guid) {\n      if(guid == null) { return \"self.noop\"; }\n\n      var child = this.environment.children[guid],\n          depths = child.depths.list;\n      var programParams = [child.index, child.name, \"data\"];\n\n      for(var i=0, l = depths.length; i<l; i++) {\n        depth = depths[i];\n\n        if(depth === 1) { programParams.push(\"depth0\"); }\n        else { programParams.push(\"depth\" + (depth - 1)); }\n      }\n\n      if(depths.length === 0) {\n        return \"self.program(\" + programParams.join(\", \") + \")\";\n      } else {\n        programParams.shift();\n        return \"self.programWithDepth(\" + programParams.join(\", \") + \")\";\n      }\n    },\n\n    register: function(name, val) {\n      this.useRegister(name);\n      this.source.push(name + \" = \" + val + \";\");\n    },\n\n    useRegister: function(name) {\n      if(!this.context.registers[name]) {\n        this.context.registers[name] = true;\n        this.context.registers.list.push(name);\n      }\n    },\n\n    pushStack: function(item) {\n      this.source.push(this.nextStack() + \" = \" + item + \";\");\n      return \"stack\" + this.stackSlot;\n    },\n\n    nextStack: function() {\n      this.stackSlot++;\n      if(this.stackSlot > this.stackVars.length) { this.stackVars.push(\"stack\" + this.stackSlot); }\n      return \"stack\" + this.stackSlot;\n    },\n\n    popStack: function() {\n      return \"stack\" + this.stackSlot--;\n    },\n\n    topStack: function() {\n      return \"stack\" + this.stackSlot;\n    },\n\n    quotedString: function(str) {\n      return '\"' + str\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g, '\\\\\"')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r') + '\"';\n    }\n  };\n\n  var reservedWords = (\n    \"break else new var\" +\n    \" case finally return void\" +\n    \" catch for switch while\" +\n    \" continue function this with\" +\n    \" default if throw\" +\n    \" delete in try\" +\n    \" do instanceof typeof\" +\n    \" abstract enum int short\" +\n    \" boolean export interface static\" +\n    \" byte extends long super\" +\n    \" char final native synchronized\" +\n    \" class float package throws\" +\n    \" const goto private transient\" +\n    \" debugger implements protected volatile\" +\n    \" double import public let yield\"\n  ).split(\" \");\n\n  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};\n\n  for(var i=0, l=reservedWords.length; i<l; i++) {\n    compilerWords[reservedWords[i]] = true;\n  }\n\n\tJavaScriptCompiler.isValidJavaScriptVariableName = function(name) {\n\t\tif(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]+$/.test(name)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n})(Handlebars.Compiler, Handlebars.JavaScriptCompiler);\n\nHandlebars.precompile = function(string, options) {\n  options = options || {};\n\n  var ast = Handlebars.parse(string);\n  var environment = new Handlebars.Compiler().compile(ast, options);\n  return new Handlebars.JavaScriptCompiler().compile(environment, options);\n};\n\nHandlebars.compile = function(string, options) {\n  options = options || {};\n\n  var compiled;\n  function compile() {\n    var ast = Handlebars.parse(string);\n    var environment = new Handlebars.Compiler().compile(ast, options);\n    var templateSpec = new Handlebars.JavaScriptCompiler().compile(environment, options, undefined, true);\n    return Handlebars.template(templateSpec);\n  }\n\n  // Template is only compiled on first use and cached after that point.\n  return function(context, options) {\n    if (!compiled) {\n      compiled = compile();\n    }\n    return compiled.call(this, context, options);\n  };\n};\n;\n// lib/handlebars/runtime.js\nHandlebars.VM = {\n  template: function(templateSpec) {\n    // Just add water\n    var container = {\n      escapeExpression: Handlebars.Utils.escapeExpression,\n      invokePartial: Handlebars.VM.invokePartial,\n      programs: [],\n      program: function(i, fn, data) {\n        var programWrapper = this.programs[i];\n        if(data) {\n          return Handlebars.VM.program(fn, data);\n        } else if(programWrapper) {\n          return programWrapper;\n        } else {\n          programWrapper = this.programs[i] = Handlebars.VM.program(fn);\n          return programWrapper;\n        }\n      },\n      programWithDepth: Handlebars.VM.programWithDepth,\n      noop: Handlebars.VM.noop\n    };\n\n    return function(context, options) {\n      options = options || {};\n      return templateSpec.call(container, Handlebars, context, options.helpers, options.partials, options.data);\n    };\n  },\n\n  programWithDepth: function(fn, data, $depth) {\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    return function(context, options) {\n      options = options || {};\n\n      return fn.apply(this, [context, options.data || data].concat(args));\n    };\n  },\n  program: function(fn, data) {\n    return function(context, options) {\n      options = options || {};\n\n      return fn(context, options.data || data);\n    };\n  },\n  noop: function() { return \"\"; },\n  invokePartial: function(partial, name, context, helpers, partials, data) {\n    options = { helpers: helpers, partials: partials, data: data };\n\n    if(partial === undefined) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be found\");\n    } else if(partial instanceof Function) {\n      return partial(context, options);\n    } else if (!Handlebars.compile) {\n      throw new Handlebars.Exception(\"The partial \" + name + \" could not be compiled when running in runtime-only mode\");\n    } else {\n      partials[name] = Handlebars.compile(partial);\n      return partials[name](context, options);\n    }\n  }\n};\n\nHandlebars.template = Handlebars.VM.template;\n;\n"]],"start1":0,"start2":0,"length1":0,"length2":49699}]],"length":49699}
